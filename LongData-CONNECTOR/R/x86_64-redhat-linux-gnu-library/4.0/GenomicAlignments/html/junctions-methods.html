<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Extract junctions from genomic alignments</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for junctions-methods {GenomicAlignments}"><tr><td>junctions-methods {GenomicAlignments}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Extract junctions from genomic alignments</h2>

<h3>Description</h3>

<p>Given an object <code>x</code> containing genomic alignments (e.g. a
<a href="GAlignments-class.html">GAlignments</a>, <a href="GAlignmentPairs-class.html">GAlignmentPairs</a>, or <a href="GAlignmentsList-class.html">GAlignmentsList</a>
object), <code>junctions(x)</code> extracts the junctions from it and
<code>summarizeJunctions(x)</code> extracts and summarizes them.
</p>
<p><code>readTopHatJunctions</code> and <code>readSTARJunctions</code> are utilities
for importing the junction file generated by the TopHat and STAR
aligners, respectively.
</p>


<h3>Usage</h3>

<pre>
## junctions() generic and methods
## -------------------------------

junctions(x, use.mcols=FALSE, ...)

## S4 method for signature 'GAlignments'
junctions(x, use.mcols=FALSE)

## S4 method for signature 'GAlignmentPairs'
junctions(x, use.mcols=FALSE)

## S4 method for signature 'GAlignmentsList'
junctions(x, use.mcols=FALSE, ignore.strand=FALSE)

## summarizeJunctions() and NATURAL_INTRON_MOTIFS
## ----------------------------------------------

summarizeJunctions(x, with.revmap=FALSE, genome=NULL)

NATURAL_INTRON_MOTIFS

## Utilities for importing the junction file generated by some aligners
## --------------------------------------------------------------------

readTopHatJunctions(file, file.is.raw.juncs=FALSE)

readSTARJunctions(file)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>A <a href="GAlignments-class.html">GAlignments</a>, <a href="GAlignmentPairs-class.html">GAlignmentPairs</a>, or <a href="GAlignmentsList-class.html">GAlignmentsList</a>
object.
</p>
</td></tr>
<tr valign="top"><td><code>use.mcols</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
Whether the metadata columns on <code>x</code> (accessible with <code>mcols(x)</code>)
should be propagated to the returned object or not.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>Additional arguments, for use in specific methods.
</p>
</td></tr>
<tr valign="top"><td><code>ignore.strand</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
If set to <code>TRUE</code>, then the strand of <code>x</code> is set to <code>"*"</code>
prior to any computation.
</p>
</td></tr>
<tr valign="top"><td><code>with.revmap</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
If set to <code>TRUE</code>, then a <code>revmap</code> metadata column is added to
the output of <code>summarizeJunctions</code>. This metadata column is an
<a href="../../IRanges/html/IntegerList.html">IntegerList</a> object representing the mapping from each
element in the ouput (i.e. each junction) to the corresponding elements in
the input <code>x</code>.
</p>
</td></tr>
<tr valign="top"><td><code>genome</code></td>
<td>

<p><code>NULL</code> (the default), or a <a href="../../BSgenome/html/BSgenome.html">BSgenome</a> object
containing the sequences of the reference genome that was used to align
the reads, or the name of this reference genome specified in a way that
is accepted by the <code><a href="../../BSgenome/html/getBSgenome.html">getBSgenome</a></code> function defined
in the <span class="pkg">BSgenome</span> software package. In that case the corresponding
BSgenome data package needs to be already installed (see
<code>?<a href="../../BSgenome/html/getBSgenome.html">getBSgenome</a></code> in the <span class="pkg">BSgenome</span> package for
the details).
</p>
<p>If <code>genome</code> is supplied, then the <code>intron_motif</code> and
<code>intron_strand</code> metadata columns are computed (based on the
dinucleotides found at the intron boundaries) and added to the output
of <code>summarizeJunctions</code>. See the Value section below for a
description of these metadata columns.
</p>
</td></tr>
<tr valign="top"><td><code>file</code></td>
<td>

<p>The path (or a connection) to the junction file generated by the aligner.
This file should be the <em>junctions.bed</em> or <em>new_list.juncs</em>
file for <code>readTopHatJunctions</code>, and the <em>SJ.out.tab</em> file for
<code>readSTARJunctions</code>.
</p>
</td></tr>
<tr valign="top"><td><code>file.is.raw.juncs</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
If set to <code>TRUE</code>, then the input file is assumed to be a TopHat
<em>.juncs</em> file instead of the <em>junctions.bed</em> file generated
by TopHat. A TopHat <em>.juncs</em> file can be obtained by passing the
<em>junctions.bed</em> file thru TopHat's <em>bed_to_juncs</em> script.
See the TopHat manual at <a href="http://tophat.cbcb.umd.edu/manual.shtml">http://tophat.cbcb.umd.edu/manual.shtml</a>
for more information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An N operation in the CIGAR of a genomic alignment is interpreted as a
junction. <code>junctions(x)</code> will return the genomic ranges of all
junctions found in <code>x</code>.
</p>
<p>More precisely, on a <a href="GAlignments-class.html">GAlignments</a> object <code>x</code>,
<code>junctions(x)</code> is equivalent to:
</p>
<pre>  psetdiff(granges(x), grglist(x, order.as.in.query=TRUE))
</pre>
<p>On a <a href="GAlignmentPairs-class.html">GAlignmentPairs</a> object <code>x</code>, it's equivalent to (but
faster than):
</p>
<pre>  mendoapply(c, junctions(first(x, real.strand=TRUE)),
                junctions(last(x, real.strand=TRUE)))
</pre>
<p>Note that starting with BioC 3.2, the behavior of <code>junctions</code> on a
<a href="GAlignmentPairs-class.html">GAlignmentPairs</a> object has been slightly modified so that the
returned ranges now have the <em>real strand</em> set on them. See the
documentation of the <code>real.strand</code> argument in the man page of
<a href="GAlignmentPairs-class.html">GAlignmentPairs</a> objects for more information.
</p>
<p><code>NATURAL_INTRON_MOTIFS</code> is a predefined character vector containing
the 5 natural intron motifs described at
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC84117/">http://www.ncbi.nlm.nih.gov/pmc/articles/PMC84117/</a>.
</p>


<h3>Value</h3>

<p><code>junctions(x)</code> returns the genomic ranges of the junctions in a
<a href="../../GenomicRanges/html/GRangesList.html">GRangesList</a> object <em>parallel</em> to <code>x</code>
(i.e. with 1 list element per element in <code>x</code>).
If <code>x</code> has names on it, they're propagated to the returned object.
If <code>use.mcols</code> is TRUE and <code>x</code> has metadata columns on it
(accessible with <code>mcols(x)</code>), they're propagated to the returned object.
</p>
<p><code>summarizeJunctions</code> returns the genomic ranges of the unique
junctions in <code>x</code> in an unstranded <a href="../../GenomicRanges/html/GRanges.html">GRanges</a>
object with the following metadata columns:
</p>

<ul>
<li> <p><code>score</code>: The total number of alignments crossing each
junction, i.e. that have the junction encoded in their CIGAR.
</p>
</li>
<li> <p><code>plus_score</code> and <code>minus_score</code>: The strand-specific
number of alignments crossing each junction.
</p>
</li>
<li> <p><code>revmap</code>: [Only if <code>with.revmap</code> was set to <code>TRUE</code>.]
An <a href="../../IRanges/html/IntegerList.html">IntegerList</a> object representing the mapping from
each element in the ouput (i.e. each junction) to the corresponding
elements in input <code>x</code>.
</p>
</li>
<li> <p><code>intron_motif</code> and <code>intron_strand</code>: [Only if <code>genome</code>
was supplied.] The intron motif and strand for each junction,
based on the dinucleotides found in the genome sequences at the
intron boundaries.
The <code>intron_motif</code> metadata column is a factor whose levels
are the 5 natural intron motifs stored in predefined character
vector <code>NATURAL_INTRON_MOTIFS</code>.
If the dinucleotides found at the intron boundaries don't match
any of these natural intron motifs, then <code>intron_motif</code> and
<code>intron_strand</code> are set to <code>NA</code> and <code>*</code>,
respectively.
</p>
</li></ul>

<p><code>readTopHatJunctions</code> and <code>readSTARJunctions</code> return the
junctions reported in the input file in a stranded
<a href="../../GenomicRanges/html/GRanges.html">GRanges</a> object.
With the following metadata columns for <code>readTopHatJunctions</code> (when
reading in the <em>junctions.bed</em> file):
</p>

<ul>
<li> <p><code>name</code>: An id assigned by TopHat to each junction. This id is
of the form JUNC00000017 and is unique within the
<em>junctions.bed</em> file.
</p>
</li>
<li> <p><code>score</code>: The total number of alignments crossing each
junction.
</p>
</li></ul>

<p>With the following metadata columns for <code>readSTARJunctions</code>:
</p>

<ul>
<li> <p><code>intron_motif</code> and <code>intron_strand</code>:
The intron motif and strand for each junction, based on the code
found in the input file (0: non-canonical, 1: GT/AG, 2: CT/AC,
3: GC/AG, 4: CT/GC, 5: AT/AC, 6: GT/AT).
Note that of the 5 natural intron motifs stored in predefined
character vector <code>NATURAL_INTRON_MOTIFS</code>, only the first 3 are
assigned codes by the STAR software (2 codes per motif, one if the
intron is on the plus strand and one if it's on the minus strand).
Thus the <code>intron_motif</code> metadata column is a factor with only
3 levels. If code is 0, then <code>intron_motif</code> and
<code>intron_strand</code> are set to <code>NA</code> and <code>*</code>, respectively.
</p>
</li>
<li> <p><code>um_reads</code>: The number of uniquely mapping reads crossing
the junction (a pair where the 2 alignments cross the same junction
is counted only once).
</p>
</li>
<li> <p><code>mm_reads</code>: The number of multi-mapping reads crossing the
junction (a pair where the 2 alignments cross the same junction is
counted only once).
</p>
</li></ul>

<p>See STAR manual at <a href="https://code.google.com/p/rna-star/">https://code.google.com/p/rna-star/</a> for more
information.
</p>


<h3>Author(s)</h3>

<p>Hervé Pagès</p>


<h3>References</h3>

<p><a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC84117/">http://www.ncbi.nlm.nih.gov/pmc/articles/PMC84117/</a> for the 5 natural
intron motifs stored in predefined character vector
<code>NATURAL_INTRON_MOTIFS</code>.
</p>
<p>TopHat2: accurate alignment of transcriptomes in the presence of insertions,
deletions and gene fusions
</p>

<ul>
<li><p> TopHat2 paper: <a href="http://genomebiology.com/2013/14/4/r36">http://genomebiology.com/2013/14/4/r36</a>
</p>
</li>
<li><p> TopHat2 software and manual: <a href="http://tophat.cbcb.umd.edu/">http://tophat.cbcb.umd.edu/</a>
</p>
</li></ul>

<p>STAR: ultrafast universal RNA-seq aligner
</p>

<ul>
<li><p> STAR paper: <a href="http://bioinformatics.oxfordjournals.org/content/early/2012/10/25/bioinformatics.bts635">http://bioinformatics.oxfordjournals.org/content/early/2012/10/25/bioinformatics.bts635</a>
</p>
</li>
<li><p> STAR software and manual: <a href="https://code.google.com/p/rna-star/">https://code.google.com/p/rna-star/</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> The <code><a href="readGAlignments.html">readGAlignments</a></code> and
<code><a href="readGAlignments.html">readGAlignmentPairs</a></code> functions for reading genomic
alignments from a BAM file.
</p>
</li>
<li> <p><a href="GAlignments-class.html">GAlignments</a>, <a href="GAlignmentPairs-class.html">GAlignmentPairs</a>, and
<a href="GAlignmentsList-class.html">GAlignmentsList</a> objects.
</p>
</li>
<li> <p><a href="../../GenomicRanges/html/GRanges.html">GRanges</a> and <a href="../../GenomicRanges/html/GRangesList.html">GRangesList</a>
objects implemented and documented in the <span class="pkg">GenomicRanges</span>
package.
</p>
</li>
<li> <p><a href="../../IRanges/html/IntegerList.html">IntegerList</a> objects implemented and documented
in the <span class="pkg">IRanges</span> package.
</p>
</li>
<li><p> The <code><a href="../../BSgenome/html/getBSgenome.html">getBSgenome</a></code> function in the
<span class="pkg">BSgenome</span> package, for searching the installed BSgenome
data packages for the specified genome and returning it as a
<a href="../../BSgenome/html/BSgenome.html">BSgenome</a> object.
</p>
</li>
<li><p> The <code><a href="../../IRanges/html/extractList.html">extractList</a></code> function in the <span class="pkg">IRanges</span>
package, for extracting groups of elements from a vector-like object
and returning them into a <a href="../../S4Vectors/html/List.html">List</a> object.
</p>
</li></ul>



<h3>Examples</h3>

<pre>
library(RNAseqData.HNRNPC.bam.chr14)
bamfile &lt;- RNAseqData.HNRNPC.bam.chr14_BAMFILES[1]

## ---------------------------------------------------------------------
## A. junctions()
## ---------------------------------------------------------------------

gal &lt;- readGAlignments(bamfile)
table(njunc(gal))  # some alignments have 3 junctions!
juncs &lt;- junctions(gal)
juncs

stopifnot(identical(unname(elementNROWS(juncs)), njunc(gal)))

galp &lt;- readGAlignmentPairs(bamfile)
juncs &lt;- junctions(galp)
juncs

stopifnot(identical(unname(elementNROWS(juncs)), njunc(galp)))

## ---------------------------------------------------------------------
## B. summarizeJunctions()
## ---------------------------------------------------------------------

## By default, only the "score", "plus_score", and "minus_score"
## metadata columns are returned:
junc_summary &lt;- summarizeJunctions(gal)
junc_summary

## The "score" metadata column reports the total number of alignments
## crossing each junction, i.e., that have the junction encoded in their
## CIGAR:
median(mcols(junc_summary)$score)

## The "plus_score" and "minus_score" metadata columns report the
## strand-specific number of alignments crossing each junction:
stopifnot(identical(mcols(junc_summary)$score,
                    mcols(junc_summary)$plus_score +
                    mcols(junc_summary)$minus_score))

## If 'with.revmap' is TRUE, the "revmap" metadata column is added to
## the output. This metadata column is an IntegerList object represen-
## ting the mapping from each element in the ouput (i.e. a junction) to
## the corresponding elements in the input 'x'. Here we're going to use
## this to compute a 'score2' for each junction. We obtain this score
## by summing the mapping qualities of the alignments crossing the
## junction:
gal &lt;- readGAlignments(bamfile, param=ScanBamParam(what="mapq"))
junc_summary &lt;- summarizeJunctions(gal, with.revmap=TRUE)
junc_score2 &lt;- sum(extractList(mcols(gal)$mapq,
                               mcols(junc_summary)$revmap))
mcols(junc_summary)$score2 &lt;- junc_score2

## If the name of the reference genome is specified thru the 'genome'
## argument (in which case the corresponding BSgenome data package needs
## to be installed), then summarizeJunctions() returns the intron motif
## and strand for each junction.
## Since the reads in RNAseqData.HNRNPC.bam.chr14 were aligned to
## the hg19 genome, the following requires that you have
## BSgenome.Hsapiens.UCSC.hg19 installed:
junc_summary &lt;- summarizeJunctions(gal, with.revmap=TRUE, genome="hg19")
mcols(junc_summary)$score2 &lt;- junc_score2  # putting 'score2' back

## The "intron_motif" metadata column is a factor whose levels are the
## 5 natural intron motifs stored in predefined character vector
## 'NATURAL_INTRON_MOTIFS':
table(mcols(junc_summary)$intron_motif)

## ---------------------------------------------------------------------
## C. STRANDED RNA-seq PROTOCOL
## ---------------------------------------------------------------------

## Here is a simple test for checking whether the RNA-seq protocol was
## stranded or not:
strandedTest &lt;- function(plus_score, minus_score)
    (sum(plus_score ^ 2) + sum(minus_score ^ 2)) /
        sum((plus_score + minus_score) ^ 2)

## The result of this test is guaranteed to be &gt;= 0.5 and &lt;= 1.
## If, for each junction, the strand of the crossing alignments looks
## random (i.e. "plus_score" and "minus_score" are close), then
## strandedTest() will return a value close to 0.5. If it doesn't look
## random (i.e. for each junction, one of "plus_score" and "minus_score"
## is much bigger than the other), then strandedTest() will return a
## value close to 1.

## If the reads are single-end, the test is meaningful when applied
## directly on 'junc_summary'. However, for the test to be meaningful
## on paired-end reads, it needs to be applied on the first and last
## alignments separately:
junc_summary1 &lt;- summarizeJunctions(first(galp))
junc_summary2 &lt;- summarizeJunctions(last(galp))
strandedTest(mcols(junc_summary1)$plus_score,
             mcols(junc_summary1)$minus_score)
strandedTest(mcols(junc_summary2)$plus_score,
             mcols(junc_summary2)$minus_score)
## Both values are close to 0.5 which suggests that the RNA-seq protocol
## used for this experiment was not stranded.

## ---------------------------------------------------------------------
## D. UTILITIES FOR IMPORTING THE JUNCTION FILE GENERATED BY SOME
##    ALIGNERS
## ---------------------------------------------------------------------

## The TopHat aligner generates a junctions.bed file where it reports
## all the junctions satisfying some "quality" criteria (see the TopHat
## manual at http://tophat.cbcb.umd.edu/manual.shtml for more
## information). This file can be loaded with readTopHatJunctions():
runname &lt;- names(RNAseqData.HNRNPC.bam.chr14_BAMFILES)[1]
junctions_file &lt;- system.file("extdata", "tophat2_out", runname,
                              "junctions.bed",
                              package="RNAseqData.HNRNPC.bam.chr14")
th_junctions &lt;- readTopHatJunctions(junctions_file)

## Comparing the "TopHat junctions" with the result of
## summarizeJunctions():
th_junctions14 &lt;- th_junctions
seqlevels(th_junctions14, pruning.mode="coarse") &lt;- "chr14"
mcols(th_junctions14)$intron_strand &lt;- strand(th_junctions14)
strand(th_junctions14) &lt;- "*"

## All the "TopHat junctions" are in 'junc_summary':
stopifnot(all(th_junctions14 %in% junc_summary))

## But not all the junctions in 'junc_summary' are reported by TopHat
## (that's because TopHat reports only junctions that satisfy some
## "quality" criteria):
is_in_th_junctions14 &lt;- junc_summary %in% th_junctions14
table(is_in_th_junctions14)  # 32 junctions are not in TopHat's
                             # junctions.bed file
junc_summary2 &lt;- junc_summary[is_in_th_junctions14]

## 'junc_summary2' and 'th_junctions14' contain the same junctions in
## the same order:
stopifnot(all(junc_summary2 == th_junctions14))

## Let's merge their metadata columns. We use our own version of
## merge() for this, which is stricter (it checks that the common
## columns are the same in the 2 data frames to merge) and also
## simpler:
merge2 &lt;- function(df1, df2)
{
    common_colnames &lt;- intersect(colnames(df1), colnames(df2))
    lapply(common_colnames,
           function(colname)
             stopifnot(all(df1[ , colname] == df2[ , colname])))
    extra_mcolnames &lt;- setdiff(colnames(df2), colnames(df1))
    cbind(df1, df2[ , extra_mcolnames, drop=FALSE])
}

mcols(th_junctions14) &lt;- merge2(mcols(th_junctions14),
                                mcols(junc_summary2))

## Here is a peculiar junction reported by TopHat:
idx0 &lt;- which(mcols(th_junctions14)$score2 == 0L)
th_junctions14[idx0]
gal[mcols(th_junctions14)$revmap[[idx0]]]
## The junction is crossed by 5 alignments (score is 5), all of which
## have a mapping quality of 0!
</pre>

<hr /><div style="text-align: center;">[Package <em>GenomicAlignments</em> version 1.26.0 <a href="00Index.html">Index</a>]</div>
</body></html>
